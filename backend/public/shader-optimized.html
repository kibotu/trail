<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Shader - 383 chars</title>
    <link rel="icon" type="image/x-icon" href="/assets/favicon.ico">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="info">
        Optimized Shader (383 chars)<br>
        Tone mapping + Vignette
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas to fill window
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener('resize', resize);

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const isWebGL2 = gl.constructor.name === 'WebGL2RenderingContext';
        
        // Fragment shader - optimized version with tone mapping
        const fragmentShaderSource = `
            precision highp float;
            uniform vec3 iResolution;
            uniform float iTime;

            ${isWebGL2 ? '' : `
            // Manual tanh implementation for WebGL1
            float tanh(float x) {
                float e = exp(2.0 * x);
                return (e - 1.0) / (e + 1.0);
            }
            `}
            
            vec2 tanh(vec2 x) {
                return vec2(tanh(x.x), tanh(x.y));
            }
            
            vec4 tanh(vec4 x) {
                return vec4(tanh(x.x), tanh(x.y), tanh(x.z), tanh(x.w));
            }

            void mainImage(out vec4 o, vec2 u) {
                vec2 v = iResolution.xy;
                vec2 w = u = .2 * (u + u - v) / v.y;    
                     
                vec4 z = o = vec4(1, 2, 3, 0);
                
                float a = .5;
                float t = iTime;
                 
                for (float i = 0.; i < 19.; i += 1.) {
                    o += (1. + cos(z + t)) / length((1.+i*dot(v,v)) * sin(1.5*u/(.5-dot(u,u)) - 9.*u.yx + t));
                    
                    t += 1.;
                    a += .03;
                    v = cos(t - 7.*u*pow(a, i)) - 5. * u;
                    
                    u *= mat2(cos(i + .02 * t - vec4(0, 11, 33, 0)));
                    u += tanh(40. * dot(u, u) * cos(1e2 * u.yx + t)) / 2e2
                       + .2 * a * u + cos(4. / exp(dot(o, o) / 1e2) + t) / 3e2;
                }
                          
                o = tanh(o / 5.9) - dot(w, w);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            throw new Error('Program link failed');
        }

        gl.useProgram(program);

        // Setup geometry (fullscreen quad)
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Get uniform locations
        const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
        const iTimeLocation = gl.getUniformLocation(program, 'iTime');

        // Animation loop
        const startTime = Date.now();
        
        function render() {
            const time = (Date.now() - startTime) / 1000;
            
            gl.uniform3f(iResolutionLocation, canvas.width, canvas.height, 1.0);
            gl.uniform1f(iTimeLocation, time);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
